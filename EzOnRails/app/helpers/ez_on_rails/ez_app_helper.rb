# frozen_string_literal: true

# Helper module for this application generated by the EzOnRails:EzApp generator.
module EzOnRails::EzAppHelper
  # Constant defining the types of flash messages, if they are not given by any bootstap conform alert key
  # If the types are not "overriden" here, the key itselfs of some flash message will be used as type
  FLASH_MESSAGE_TYPES = {
    error: :alert,
    notice: :primary,
    alert: :danger
  }.freeze

  # Number of milliseconds a flash message is visible. After that timeout the message will be
  # dismissed automaticly.
  FLASH_MESSAGE_TIMEOUT = 5000

  # Renders one breadcrumb item.
  def breadcrumb_item(crumb)
    link_to(crumb.name,
            crumb.url,
            (crumb.current? ? { 'aria-current' => 'page' } : {}).merge(
              style: "color: #{header_text_color};",
              class: 'opacity-50 text-decoration-none'
            ))
  end

  # Returns the title of the current page.
  # If the title is not defined in the locals passed to the view by the controller, it will
  # be selected from its instance variable.
  # Since the helpers are not able to access the locals, they must be passed as parameters.
  def page_title(locals)
    if locals[:title]
      locals[:title]
    else
      defined?(@title) ? @title : ''
    end
  end

  # Returns the subtitle of the current page.
  # If the subtitle is not defined in the locals passed to the view by the controller, it will
  # be selected from its instance variable.
  # Since the helpers are not able to access the locals, they must be passed as parameters.
  def page_subtitle(locals)
    if locals[:subtitle]
      locals[:subtitle]
    else
      defined?(@subtitle) ? @subtitle : ''
    end
  end

  # Returns wether the pages title should be printed.
  # Since the helpers are not able to access the locals, they must be passed as parameters.
  def print_title?(locals)
    locals[:title] || defined?(@title) || locals[:subtitle] || defined?(@subtitle)
  end

  # Returns the tag for a button in a modal in the modal partial.
  # the specified options has to have the following entries.
  # The :id should be a unique id in the modal, to access the button in some javascript.
  # The :label is the text inside the button.
  # The :type can be any bootstrap button type like primary, secondary etc.
  # The :method can be any http method (:get, :post, ...). If not specified, the default will be :get
  # The :target can be any rails compatible link option, like a hash to an action and controller,
  # a link or something else.
  def modal_button(options)
    unless options[:target]
      return button_tag options[:label],
                        id: options[:id],
                        class: "btn btn-#{options[:type] || 'secondary'}",
                        'data-bs-dismiss': 'modal'
    end

    link_to options[:label],
            options[:target],
            data: {
              turbo_method: (options[:method] || :get),
              'bs-dismiss': 'modal'
            },
            class: "btn btn-#{options[:type] || 'secondary'}",
            id: options[:id]
  end

  # Renders an yes no modal having the specified title and content.
  # By pressing the yes button, the target_yes target will be called. this can be any rails compatible
  # target type like an action and controller, link or something else.
  # content can be any valid html or simple text.
  # The options hash can contain the values for :id, :label_yes and :label_no.
  # If label_yes or label_no is not defined, the default labels will be taken.
  # The id can be specified to target the modal or its buttons in javascript.
  # The buttons have the ids #{id}_button_yes and #{id}_button_no.
  # Note that you have to call the modal using javascript or bootstrap. Read the bootstrap documentation
  # for more information.
  def modal_yes_no(title, content, target_yes = nil, options = {})
    render partial: 'ez_on_rails/shared/modals/yes_no', locals: {
      id: options[:id] || 'yes_no',
      title: title,
      content: content,
      target_yes: target_yes,
      label_yes: options[:label_yes],
      label_no: options[:label_no]
    }
  end

  # Renders an ok modal having the specified title and content.
  # By pressing the ok button, the target_ok target will be called. this can be any raiuls compatible
  # target type like an action and controller, link or something else.
  # content can be any valid html or simple text.
  # The options hash can contain the values for :id and :label_ok.
  # If label_ok is not defined, the default label will be taken.
  # The id can be specified to target the modal or its button in javascript.
  # The button has the id #{id}_button_ok.
  # Note that you have to call the modal using javascript or bootstrap. Read the bootstrap documentation
  # for more information.
  def modal_ok(title, content, target_ok = nil, options = {})
    render partial: 'ez_on_rails/shared/modals/ok', locals: {
      id: options[:id] || 'ok',
      title: title,
      content: content,
      target_ok: target_ok,
      label_ok: options[:label_ok]
    }
  end

  # Renders a preview modal, having only the specified content without title and buttons.
  # The options hash can obtain the value for :id.
  # The id can be specified to target the modal or its button in javascript.
  # Note that you have to call the modal using javascript or bootstrap. Read the bootstrap documentation
  # for more information.
  def modal_preview(content, options)
    render partial: 'ez_on_rails/shared/modals/preview', locals: {
      id: options[:id] || 'preview',
      content: content
    }
  end

  # Renders the custom modal having the specified title and content.
  # The buttons has to be an array containing hashes with button information,
  # like they are needed from the modal_button function in this helper.
  # The content can be any valid html or text.
  # The options hash can contain the value for :id.
  # The id can be used to access the modal in javascript.
  # Note that you have to call the modal using javascript or bootstrap. Read the bootstrap documentation
  # for more information.
  def modal(title, content, buttons, options = {})
    render partial: 'ez_on_rails/shared/modals/modal', locals: {
      id: options[:id] || 'modal',
      title: title,
      content: content,
      buttons: buttons
    }
  end

  # Renders a form of some ezscaff model in a modal.
  # The model_form_locals are the same locals which can be passed to a default model_form.
  # For instance the render_info and the obj variable are expected here.
  # The options hash can contain the value for :id.
  # Care by using this, it is prefered to target to an extra post action which does not redirect the user.
  def modal_model_form(title, model_form_locals, options = {})
    render partial: 'ez_on_rails/shared/modals/model_form',
           locals: model_form_locals.merge(id: options[:id] || 'form', title: title)
  end

  # Renders a button targeting a modal.
  # The modal of the given modal_id will be opened by clicking this button.
  # Content is the content displayed inside the button.
  # This can be anything which can be displayed inside a html button tag, for instance some
  # text or image.
  # The html options are passed to the button.
  # The button itselfs is a bootstrap button by default. if no class is specified, the bootstrap button will
  # be rendered as btn-secondary.
  def target_modal_button(content, modal_id, html_options = {})
    html_options[:class] = "btn #{html_options[:class] || 'btn-secondary'}"
    html_options['data-toggle'] = 'modal'
    html_options['data-target'] = "##{modal_id}"
    html_options[:type] = 'button'

    button_tag content, html_options
  end

  # Renders an icon tag having the specified icon name.
  # The html options can be used to pass css classes to the icon tag.
  # Currently font awesome icons are used.
  def ez_icon(icon, html_options = {})
    tag.i class: "fas #{html_options[:class] || ''} fa-#{icon}", **html_options.except(:class)
  end

  # Returns a span tag holding an icon followed by a text.
  # The icon is rendered using ez_icon, hence only the icon name is needed.
  # Can be used eg. for buttons.
  def icon_with_text(icon, text)
    tag.span(ez_icon(icon, class: 'me-2') + tag.span(text))
  end

  # Returns the type of some flash message given by its key.
  # The type defines the bootstraop compatible alert type, like warning, danger etc.
  # This function wraps the names given by some rails keys to the corresponding bootstrap types.
  def flash_message_type(key)
    FLASH_MESSAGE_TYPES[key.to_sym] || key.to_sym
  end

  # Encloses the content defined by a block with a details summary html5 tag
  # if the given condition lambda or proc returns true. Otherweise the block will be returned
  # itself without being enclosed by the details tag.
  # The summaray parameter defines the content of the summary block.
  # The options hash can contain :class_summary and :class_details attributes, which are passed
  # as css classes to the tags.
  # :open can be given the value true, to let the tag be opened at the beginning.
  def enclose_with_details_if(condition, summary, options = {}, &block)
    # If the condition is not true just print the block
    return capture(&block) unless condition.call

    # Otherwise return the details tag
    tag.details(
      tag.summary(summary, class: options[:class_summary]) + capture(&block),
      class: options[:class_details],
      open: options[:open]
    )
  end

  # Returns a tag that shows a flag-icon for the specified lang code.
  def flag_icon(lang_code)
    tag.span '', class: "fi fi-#{lang_code}"
  end
end
