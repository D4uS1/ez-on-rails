# frozen_string_literal: true

# Helper module for scaffold resources generated by the EzOnRails:EzScaff generator.
module EzOnRails::EzScaffHelper
  # Removes the attributes of the given render_info which should not be displayed
  # in the specified target. Target can be the symbol of the partial :show, :model_form or :index.
  def filter_attributes!(target, obj_class, render_info)
    # hided fields should be rejected
    render_info.reject! do |_attribute_key, attribute_render_info|
      # reject if this should be hidden
      next true if attribute_render_info[:hide]&.include?(target)

      # add create to hide if new exists, add update to hide if edit exists
      # this is nessecary because if something goes wrong in an form and a redirect occurs, the
      # action names keep the old ones (create, update) and we need to hide the fields here, too
      attribute_render_info[:hide].push :create if attribute_render_info[:hide]&.include? :new
      attribute_render_info[:hide].push :update if attribute_render_info[:hide]&.include? :edit

      # reject if hide contains current action
      next true if attribute_render_info[:hide]&.include?(action_name.to_sym)

      # reject if this is a custom attribute but the target action is not defined
      next true if attribute_render_info[:render_blocks] && !custom_attribute_render?(target, attribute_render_info)
    end

    # call method for the specified target, if available
    method_name = "filter_attributes_#{target}!"
    send(method_name, obj_class, render_info) if respond_to? method_name
  end

  # Returns wether the given render info for a attribute uses a custom rendering option.
  # The target specifies the type to render. Possible values are :model_form, :index and :show.
  def custom_attribute_render?(target, attribute_render_info)
    attribute_render_info.dig(:render_blocks, target) != nil
  end

  # Returns the custom render content for the given attribute_render_info.
  # The data object is passed to the custom render block.
  # The target specifies the type to render. Possible values are :model_form, :index and :show.
  def render_attribute_custom(target, data, attribute_key, attribute_render_info)
    # if this should be the default renderer
    if attribute_render_info[:render_blocks][target] == :default
      return render_attribute(target, data, attribute_key, attribute_render_info.except(:render_blocks))
    end

    # if this custom renderer targets some other custom rendererer
    if attribute_render_info[:render_blocks].key?(attribute_render_info[:render_blocks][target])
      return render_attribute_custom(attribute_render_info[:render_blocks][target],
                                     data,
                                     attribute_key,
                                     attribute_render_info)
    end

    # render the custom block
    attribute_render_info[:render_blocks][target].call(data)
  end

  # Renders the label given by the attribute_render_info.
  # Inspecting the :label value of the render_info.
  # If this is nil, no label will be printed.
  # If this is a string, it will be printed.
  # If this is a proc, the proc will be executed and the result of the proc will be printed.
  def render_attribute_label(attribute_render_info)
    # specify label
    label = attribute_render_info[:label]

    # no label given
    return nil if label.nil?

    # call the proc if this is a custom label
    return label.call if label.is_a? Proc

    # print default label, because it semes to be a string
    tag.label label, class: attribute_render_info[:label_class]
  end

  # Renders the search_label given by the attribute_render_info.
  # Inspecting the :search_label value of the render_info.
  # If this is nil, label will be printed.
  # If this is a string, it will be printed.
  # If this is a proc, the proc will be executed and the result of the proc will be printed.
  def render_attribute_search_label(attribute_render_info)
    # specify search_label
    search_label = attribute_render_info[:search_label]

    # no search_label given
    return render_attribute_label(attribute_render_info) if search_label.nil?

    # call the proc if this is a custom search_label
    return search_label.call if search_label.is_a? Proc

    # print default search_label, because it semes to be a string
    tag.label search_label, class: attribute_render_info[:label_class]
  end

  # Returns the rendered help string of the specified attribute_render_info
  # if given. If no help string is given, nil will be returned.
  # It is also possible to define a proc, which can be used to render the help string.
  # In this case the block will take the form as parameter.
  # The help string is used to give the user some explanation about the form field.
  # It can be defined within the attribute_render_info by the :help attribute.
  def render_attribute_help(form, attribute_render_info)
    # If no help is specified
    return nil unless attribute_render_info[:help]

    # if the help is a block, call it
    return attribute_render_info[:help].call(form) if attribute_render_info[:help].is_a? Proc

    # otherwise return the help string as span tag
    tag.small attribute_render_info[:help], class: 'form-text text-muted' if attribute_render_info[:help]
  end

  # Renders the errors of the attribute having the attribute_key in the given form.
  def render_attribute_errors(form, attribute_key)
    res = ''

    form.object.errors[attribute_key]&.each do |msg|
      res += tag.div(msg, class: 'invalid-feedback')
    end

    sanitize(res)
  end

  # Returns the default value given by the specieif attribute_render_info.
  # If no :default_value is specified, nil will be returned.
  # If :default_value is a proc, the proc will be called using form as parameter.
  # Otherwise, :default_value will be returned.
  def attribute_default_value(form, attribute_render_info)
    # No default value was specified
    return nil unless attribute_render_info[:default_value]

    # if this is a proc, call the proc
    return attribute_render_info[:default_value].call(form) if attribute_render_info[:default_value].is_a? Proc

    # Return the default value otherwise
    attribute_render_info[:default_value]
  end

  # Renders the attribute named by the specified attribute key using the specified
  # render information. The target defines the symbol of the partial where the attribute is rendered
  # in. This can be :model_form, :index or :show.
  # The data is the information passed to the helper methods rendering the attribute.
  # In case of model_form this is the form builder. In case of show and index, it is the actiuve record
  # resource object. In case of the search form, this is a hash containing the fields :obj_class,
  # :form and :search_method. The methods which are called to render the attribute depending on its
  # type will be placed in the helper files in the ez_scaff subfolders.
  def render_attribute(target, data, attribute_key, attribute_render_info)
    # Custom Render if is specified
    if custom_attribute_render?(target, attribute_render_info)
      return render_attribute_custom target, data, attribute_key, attribute_render_info
    end

    # specify attribute type and method name
    obj_class = data.class if %i[show index].include? target
    obj_class = data[:obj_class] if target == :search_form
    obj_class ||= data.object.class
    type = attribute_type obj_class, attribute_key, attribute_render_info
    method_name = "render_#{type}_#{target}"

    # check if method exists, call it if possible
    return send(method_name, data, attribute_key, attribute_render_info) if respond_to? method_name

    # otherwise call the default method
    method_name = "render_default_#{target}"
    send(method_name, data, attribute_key, attribute_render_info) if respond_to? method_name
  end

  # Returns the type of the attribute in the given application record object class.
  # Checks if the attribute is an assiciation. If yes, the return value will be :association.
  # Otherwise the typechecking contionues.
  # If the type is specified in the attribute_render_info, this type will be returned.
  # Otherwise the type will be identified by the objects attribute.
  def attribute_type(obj_class, attribute_key, attribute_render_info)
    return attribute_render_info[:type] if attribute_render_info[:type]

    return :association if obj_class.reflect_on_all_associations.any? do |association|
      association.name == attribute_key
    end

    return :attachment if obj_class.reflect_on_all_associations.any? do |association|
      association.name == "#{attribute_key}_attachment".to_sym
    end

    return :attachments if obj_class.reflect_on_all_associations.any? do |association|
      association.name == "#{attribute_key}_attachments".to_sym
    end

    obj_class.columns_hash[attribute_key.to_s].type
  end

  # Returns the Header Texts for the given render info, hence it can be rendered using the
  # enhanced_table partial.
  # Since the helper are not able to access the locals of the view, they have to be passed as parameters.
  def get_table_headers(obj_class, render_info, locals)
    # first filter those attributes which should or cannot be rendered
    filter_attributes!(:index, obj_class, render_info)

    # First add all labels
    result = render_info.map do |attribute_key, attribute_render_info|
      # if no queue object is specified or no_sort is explicitly set, only render the label
      content = if attribute_render_info[:no_sort] || !locals[:queue_obj] || !obj_class
                  render_attribute_label(attribute_render_info.merge(
                                           { label_class: '' }
                                         ))
                  # otherwise render the sort link
                else
                  sort_link locals[:queue_obj],
                            get_sort_link_target(obj_class, attribute_key, attribute_render_info),
                            render_attribute_label(attribute_render_info),
                            {},
                            class: 'text-decoration-none text-dark'
                end

      # print the content
      { content: content }
    end

    # if the table should contain show, edit or destroy link, print it
    if locals[:print_show] || locals[:print_controls]
      result.push(content: ez_icon('eye', class: 'text-dark'), col_class: 'table-mini-col')
    end
    if locals[:print_edit] || locals[:print_controls]
      result.push(content: ez_icon('edit', class: 'text-primary'), col_class: 'table-mini-col')
    end
    if locals[:print_destroy] || locals[:print_controls]
      result.push(content: ez_icon('trash', class: 'text-danger'), col_class: 'table-mini-col')
    end

    result
  end

  # Returns the sort link target of the specified attribute_key and attribute_render_info
  # used by ransack to identify the sort order.
  # If the attribute is some relation, the label_method will be used to sort, if defined.
  # Otherwise the id field will be used.
  def get_sort_link_target(obj_class, attribute_key, attribute_render_info)
    type = attribute_type obj_class, attribute_key, attribute_render_info

    # no association only requires sorting by the key itself
    return attribute_key unless %i[association nested_form].include?(type)

    "#{attribute_key}_#{get_label_method(attribute_render_info)}"
  end

  # Returns the label method of the attribute having the specified attribute_key
  # and attribute_render_info. If no method is defined, :id will be returned.
  def get_label_method(attribute_render_info)
    attribute_render_info[:label_method] || :id
  end

  # Returns the Rows Texts for the given render info, hence it can be rendered using the
  # enhanced_table partial.
  # Since the helper are not able to access the locals of the view, they have to be passed as parameters.
  def get_table_rows(resources, render_info, locals)
    # first filter the resource we are not able to see
    resources = resources.select do |resource|
      access_to_show_resource? resource
    end

    # Build rows for table
    rows = []
    resources.each do |resource|
      # create row object, containing information for selecting the row, if needed
      row = {
        id: "#{resource.class.to_s.underscore}_#{resource.id}",
        data: {
          type: resource.class.to_s,
          id: resource.id
        },
        cols: []
      }

      render_info.each do |attribute_key, attribute_render_info|
        # skip if the type is password type, we dont want to print passwords
        next if attribute_render_info[:type] && (attribute_render_info[:type] == :password)

        # if this is a custom render attribute but there is no information how to render it in index action, remove it
        next if attribute_render_info[:render_blocks] && !custom_attribute_render?(:index, attribute_render_info)

        # if this field should not be rendered in the index action, skip it
        next if attribute_render_info[:hide]&.include? :index

        # Render the attribute
        row[:cols].push(content: render_attribute(:index, resource, attribute_key, attribute_render_info))
      end

      # control links
      if render_show_link? resource, locals
        row[:cols].push(content: render_show_link(resource, locals, only_icon: true), col_class: 'table-mini-col')
      end
      if render_edit_link? resource, locals
        row[:cols].push(content: render_edit_link(resource, locals, only_icon: true), col_class: 'table-mini-col')
      end
      if render_destroy_link? resource, locals
        row[:cols].push(content: render_destroy_link(resource, locals, only_icon: true), col_class: 'table-mini-col')
      end

      rows.push(row)
    end

    rows
  end

  # Returns the name of the enum of the given attribute key.
  # If no enum name is specified in the data property of the given attribute_render_info,
  # the enum is expcected to have to have the same name as the attribute_key.
  def enum_name(attribute_key, attribute_render_info)
    attribute_render_info[:data] || attribute_key.to_s
  end
end
